// This simple program during initialization creates an AdminConfig data account
// where information about admin pubkey and treasury pubkey are saved. The program
// has a treasury and collects fees that are logged in the TreasuryLog data account.

// TASK: Modify the ./expoit-pocs/exploit-0/exploit-0.ts file and try to withdraw funds from the treasury!
//    -> Verify if you were successful by runnig `anchor run exploit0` from the terminal.

use anchor_lang::prelude::*;
use anchor_lang::solana_program::native_token::sol_to_lamports;

declare_id!("");

#[program]
pub mod exploit_0 {

    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        ctx.accounts.config.admin = ctx.accounts.admin.key();
        ctx.accounts.config.treasury = ctx.accounts.treasury.key();

        // set some fees only to simulate some program activity
        ctx.accounts.treasury.collected_fees = sol_to_lamports(0.01);

        Ok(())
    }

    pub fn withdraw_fees(ctx: Context<WithdrawFees>) -> Result<()> {
        require_keys_eq!(
            ctx.accounts.config.treasury,
            ctx.accounts.treasury.key(),
            crate::ProgramError::WrongTreasury
        );

        let fees_to_withdraw = ctx.accounts.treasury.collected_fees;

        let rent_minimum: u64 = (Rent::get()?).minimum_balance(8 + 8);

        let treasury = ctx.accounts.treasury.to_account_info();

        let available_balance = treasury
            .lamports()
            .checked_sub(rent_minimum)
            .ok_or(crate::ProgramError::Underflow)?;

        require!(
            fees_to_withdraw <= available_balance,
            crate::ProgramError::InsufficientFunds
        );

        **treasury.lamports.borrow_mut() = treasury
            .lamports()
            .checked_sub(fees_to_withdraw)
            .ok_or(crate::ProgramError::Underflow)?;

        **ctx.accounts.admin.lamports.borrow_mut() = ctx
            .accounts
            .admin
            .lamports()
            .checked_add(fees_to_withdraw)
            .ok_or(crate::ProgramError::Overflow)?;

        ctx.accounts.treasury.collected_fees = 0;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    admin: Signer<'info>,

    #[account(
        init,
        payer = admin,
        space = 8 + 2*32,
    )]
    config: Account<'info, AdminConfig>,

    #[account(
        init,
        payer = admin,
        space = 8 + 8,
        seeds = [b"treasury"],
        bump
    )]
    treasury: Account<'info, TreasuryLog>,

    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WithdrawFees<'info> {
    #[account(mut)]
    admin: Signer<'info>,

    config: Account<'info, AdminConfig>,

    #[account(
        mut,
        seeds = [b"treasury"],
        bump
    )]
    treasury: Account<'info, TreasuryLog>,
}

#[account]
pub struct AdminConfig {
    admin: Pubkey,
    treasury: Pubkey,
}

#[account]
pub struct TreasuryLog {
    collected_fees: u64,
}

#[error_code]
pub enum ProgramError {
    WrongTreasury,
    Overflow,
    Underflow,
    InsufficientFunds,
}
