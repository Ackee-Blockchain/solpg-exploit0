// The exploit-0 program creates during initialization an AdminConfig data account
// where information about admin pubkey and treasury pubkey are saved. The program
// has a treasury and collects fees that are logged in the TreasuryLog data account.

// TASK: Add your code at the indicated place bellow and try to withdraw funds from the treasury!
//    -> Verify if you were successful by runnig:
//      - `build`
//      - `deploy`
//      - `test`
//      from the Solana Playground terminal

const HACKER_INITIAL_BALANCE = anchor.web3.LAMPORTS_PER_SOL * 10;

describe("Exploit 0", async () => {
    let exploitSuccessful = false;

    const program = pg.program;

    const config = web3.Keypair.fromSeed(Uint8Array.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))
    const [treasury] = web3.PublicKey.findProgramAddressSync([anchor.utils.bytes.utf8.encode("treasury")], program.programId);
    const TREASURY_BALANCE = web3.LAMPORTS_PER_SOL * 10;

    it("Setup config and treasury!", async () => {
        const admin = web3.Keypair.generate();
        await airdrop(pg.connection, admin.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);

        const config_info = await pg.connection.getAccountInfo(config.publicKey, "confirmed");
        if (config_info === null) {
            const tx = await program.methods
                .initialize()
                .accounts({
                    admin: admin.publicKey,
                    config: config.publicKey,
                    treasury: treasury,
                    systemProgram: web3.SystemProgram.programId
                })
                .signers([admin, config])
                .rpc({ commitment: "confirmed" });

            // simulate some activity and fund the treasury
            await airdrop(pg.connection, treasury, TREASURY_BALANCE);
        }

    });

    it("Hacker tries to withdraw fees from treasury!", async () => {

        const hacker = web3.Keypair.generate();
        await airdrop(pg.connection, hacker.publicKey, HACKER_INITIAL_BALANCE);

        // x x x x x x x x x x x x x x x x x x x x x
        // | | | | | | | | | | | | | | | | | | | | |
        //           ADD YOUR CODE BELOW
        // | | | | | | | | | | | | | | | | | | | | |
        // v v v v v v v v v v v v v v v v v v v v v




        // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
        // | | | | | | | | | | | | | | | | | | | | |
        //           ADD YOUR CODE ABOVE
        // | | | | | | | | | | | | | | | | | | | | |
        // x x x x x x x x x x x x x x x x x x x x x
    });


    it("Bug evaluation", async () => {
        exploitSuccessful = false;

        await sleep(400);

        let collected_fees = (await program.account.treasuryLog.fetch(treasury)).collectedFees;

        if (collected_fees.toNumber() === 0) {
            exploitSuccessful = true;
        }
        else {
            assert.fail("You did not succeed to hack the program! Hacker was not able to withdraw fees from the protocol!");
        }

    });

    after("Evaluation", async () => {
        if (exploitSuccessful) {
            console.log('\n\n\x1b[32m', 'CONGRATULATIONS!!!\nYou succeeded to steal the fees from the protocol!', '\x1b[0m')
        }
        else {
            console.log('\n\n\x1b[31m', 'You did not suceed to exploit the program!', '\x1b[0m')
        }

    });
});


async function airdrop(connection: any, address: any, amount = 1000000000) {
    await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}
